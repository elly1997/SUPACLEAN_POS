const express = require('express');
const router = express.Router();
const db = require('../database/init');
const { generateReceiptNumber, calculateTotal, formatReceipt, formatReceiptAsync, generateReceiptQRCode } = require('../utils/receipt');
const { sendSMS, generateReadyNotification } = require('../utils/sms');
const { authenticate, requireBranchAccess } = require('../middleware/auth');
const { getBranchFilter } = require('../utils/branchFilter');
const { validatePayment } = require('../utils/paymentValidation');
const { recordPaymentTransaction, logPaymentChange } = require('../utils/paymentTransactions');
const { checkDuplicatePayment } = require('../utils/paymentTransactions');
const multer = require('multer');
const ExcelJS = require('exceljs');
const fs = require('fs');
const path = require('path');

// Ensure uploads directory exists
const uploadsDir = path.join(__dirname, '../../uploads');
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

const upload = multer({ dest: uploadsDir });

// Get all orders
router.get('/', authenticate, requireBranchAccess(), (req, res) => {
  const { 
    status, 
    customer_id, 
    date, 
    overdue_only,
    customer, // Search by customer name or phone
    date_from,
    date_to,
    min_amount,
    max_amount,
    payment_status
  } = req.query;
  
  // Get branch filter
  const branchFilter = getBranchFilter(req, 'o');
  
  let query = `
    SELECT o.*, s.name as service_name, c.name as customer_name, c.phone as customer_phone
    FROM orders o
    JOIN services s ON o.service_id = s.id
    JOIN customers c ON o.customer_id = c.id
    WHERE 1=1
    ${branchFilter.clause}
  `;
  let params = [...branchFilter.params];

  if (status) {
    query += ' AND o.status = ?';
    params.push(status);
  }

  if (customer_id) {
    query += ' AND o.customer_id = ?';
    params.push(customer_id);
  }

  // Search by customer name or phone
  if (customer) {
    query += ' AND (c.name LIKE ? OR c.phone LIKE ?)';
    const customerSearch = `%${customer}%`;
    params.push(customerSearch, customerSearch);
  }

  if (date) {
    query += ' AND DATE(o.order_date) = ?';
    params.push(date);
  }

  // Date range filters
  if (date_from) {
    query += ' AND DATE(o.order_date) >= ?';
    params.push(date_from);
  }

  if (date_to) {
    query += ' AND DATE(o.order_date) <= ?';
    params.push(date_to);
  }

  // Amount range filters
  if (min_amount) {
    query += ' AND o.total_amount >= ?';
    params.push(parseFloat(min_amount));
  }

  if (max_amount) {
    query += ' AND o.total_amount <= ?';
    params.push(parseFloat(max_amount));
  }

  // Payment status filter
  if (payment_status) {
    query += ' AND o.payment_status = ?';
    params.push(payment_status);
  }

  // Filter for overdue orders (ready but past estimated collection date)
  if (overdue_only === 'true') {
    query += ` AND o.status = 'ready' AND o.estimated_collection_date IS NOT NULL AND datetime(o.estimated_collection_date) < datetime('now')`;
  }

  query += ' ORDER BY o.order_date DESC';

  db.all(query, params, (err, rows) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    res.json(rows);
  });
});

// Get collection queue (ready orders with queue info)
router.get('/collection-queue', (req, res) => {
  const { limit = 20, overdue_only } = req.query;
  
  let query = `
    SELECT o.*, s.name as service_name, c.name as customer_name, c.phone as customer_phone,
           CASE 
             WHEN o.estimated_collection_date IS NOT NULL AND datetime(o.estimated_collection_date) < datetime('now') THEN 1
             ELSE 0
           END as is_overdue,
           CASE 
             WHEN o.estimated_collection_date IS NOT NULL THEN 
               CAST((julianday('now') - julianday(o.estimated_collection_date)) * 24 AS INTEGER)
             ELSE NULL
           END as hours_overdue
    FROM orders o
    JOIN services s ON o.service_id = s.id
    JOIN customers c ON o.customer_id = c.id
    WHERE o.status = 'ready'
  `;
  
  let params = [];
  
  if (overdue_only === 'true') {
    query += ` AND o.estimated_collection_date IS NOT NULL AND datetime(o.estimated_collection_date) < datetime('now')`;
  }
  
  query += ` ORDER BY 
    is_overdue DESC,
    CASE WHEN o.estimated_collection_date IS NOT NULL THEN o.estimated_collection_date ELSE o.ready_date END ASC
    LIMIT ?`;
  
  params.push(parseInt(limit));
  
  db.all(query, params, (err, rows) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    res.json(rows);
  });
});

// Get order by receipt number
router.get('/receipt/:receiptNumber', authenticate, requireBranchAccess(), (req, res) => {
  const { receiptNumber } = req.params;
  const branchFilter = getBranchFilter(req, 'o');
  
  db.get(
    `SELECT o.*, s.name as service_name, s.description as service_description,
            c.name as customer_name, c.phone as customer_phone, c.email as customer_email
     FROM orders o
     JOIN services s ON o.service_id = s.id
     JOIN customers c ON o.customer_id = c.id
     WHERE o.receipt_number = ?
     ${branchFilter.clause}`,
    [receiptNumber, ...branchFilter.params],
    (err, row) => {
      if (err) {
        return res.status(500).json({ error: err.message });
      }
      if (!row) {
        return res.status(404).json({ error: 'Order not found' });
      }
      res.json(row);
    }
  );
});

// Search orders by customer phone or name
router.get('/search/customer', authenticate, requireBranchAccess(), (req, res) => {
  const { phone, name, status } = req.query;
  
  if (!phone && !name) {
    return res.status(400).json({ error: 'Phone number or customer name is required' });
  }

  const branchFilter = getBranchFilter(req, 'o');

  let query = `
    SELECT o.*, s.name as service_name, s.description as service_description,
           c.name as customer_name, c.phone as customer_phone, c.email as customer_email
    FROM orders o
    JOIN services s ON o.service_id = s.id
    JOIN customers c ON o.customer_id = c.id
    WHERE 1=1
    ${branchFilter.clause}
  `;
  let params = [...branchFilter.params];

  if (phone) {
    query += ' AND c.phone LIKE ?';
    params.push(`%${phone}%`);
  }

  if (name) {
    query += ' AND c.name LIKE ?';
    params.push(`%${name}%`);
  }

  if (status) {
    query += ' AND o.status = ?';
    params.push(status);
  }

  query += ' ORDER BY o.order_date DESC LIMIT 20';

  db.all(query, params, (err, rows) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    res.json(rows);
  });
});

// Generate receipt number endpoint (for batch orders)
router.get('/generate-receipt-number', (req, res) => {
  generateReceiptNumber((err, receipt_number) => {
    if (err) {
      return res.status(500).json({ error: 'Error generating receipt number' });
    }
    res.json({ receipt_number });
  });
});

// Generate QR code for receipt
router.get('/receipt/:receiptNumber/qrcode', async (req, res) => {
  const { receiptNumber } = req.params;
  
  db.get(
    `SELECT o.*, s.name as service_name, s.description as service_description,
            c.name as customer_name, c.phone as customer_phone, c.email as customer_email
     FROM orders o
     JOIN services s ON o.service_id = s.id
     JOIN customers c ON o.customer_id = c.id
     WHERE o.receipt_number = ?
     LIMIT 1`,
    [receiptNumber],
    async (err, order) => {
      if (err) {
        return res.status(500).json({ error: err.message });
      }
      if (!order) {
        return res.status(404).json({ error: 'Order not found' });
      }
      
      try {
        const customer = {
          name: order.customer_name,
          phone: order.customer_phone,
          email: order.customer_email,
          id: order.customer_id
        };
        
        const service = {
          name: order.service_name,
          description: order.service_description,
          id: order.service_id
        };
        
        const qrCodeDataURL = await generateReceiptQRCode(order, customer, service);
        
        if (qrCodeDataURL) {
          res.json({ qrCode: qrCodeDataURL });
        } else {
          res.status(500).json({ error: 'Failed to generate QR code' });
        }
      } catch (error) {
        console.error('Error generating QR code:', error);
        res.status(500).json({ error: 'Failed to generate QR code' });
      }
    }
  );
});

// Create new order
router.post('/', authenticate, requireBranchAccess(), (req, res) => {
  try {
    console.log('POST /api/orders - Request received');
    console.log('User:', req.user?.username, 'Role:', req.user?.role, 'BranchId:', req.user?.branchId);
    
    const {
      customer_id,
      service_id,
      quantity,
      weight_kg,
      color,
      special_instructions,
      delivery_type,
      express_surcharge_multiplier,
      paid_amount,
      payment_status,
      payment_method,
      created_by,
      receipt_number, // Optional: if provided, use this receipt number (for batch orders)
      estimated_collection_date, // Estimated collection date/time
      branch_id // Optional: for admins to specify which branch to create the order for
    } = req.body;

    console.log('Order data:', { customer_id, service_id, quantity, payment_status, branch_id });

    if (!customer_id || !service_id) {
      return res.status(400).json({ error: 'Customer ID and Service ID are required' });
    }

  // Get service details and settings to calculate total
  console.log('Fetching service with id:', service_id);
  db.get('SELECT * FROM services WHERE id = ?', [service_id], (err, service) => {
    if (err) {
      console.error('Error fetching service:', err);
      return res.status(500).json({ error: err.message });
    }
    if (!service) {
      console.error('Service not found with id:', service_id);
      return res.status(404).json({ error: 'Service not found' });
    }
    console.log('Service found:', service.name);

    // Get express multipliers from settings if not provided
    let expressMultiplier = express_surcharge_multiplier || 0;
    if (delivery_type && !expressMultiplier) {
      db.all('SELECT setting_key, setting_value FROM settings WHERE setting_key IN (?, ?)', 
        ['express_same_day_multiplier', 'express_next_day_multiplier'], 
        (err, settings) => {
          if (!err && settings) {
            if (delivery_type === 'same_day') {
              const setting = settings.find(s => s.setting_key === 'express_same_day_multiplier');
              expressMultiplier = setting ? parseFloat(setting.setting_value) : 2;
            } else if (delivery_type === 'next_day') {
              const setting = settings.find(s => s.setting_key === 'express_next_day_multiplier');
              expressMultiplier = setting ? parseFloat(setting.setting_value) : 3;
            }
            createOrder();
          } else {
            createOrder();
          }
        }
      );
    } else {
      createOrder();
    }

    function createOrder(receiptNumberToUse = null, retryCount = 0) {
      // Calculate total with express surcharge
      const total_amount = calculateTotal(service, quantity || 1, weight_kg || 0, delivery_type || 'standard', expressMultiplier);
      
      // Validate payment data
      const paymentData = {
        paid_amount: paid_amount !== undefined ? paid_amount : (payment_status === 'paid_full' ? total_amount : 0),
        payment_status: payment_status || 'not_paid',
        payment_method: payment_method || 'cash'
      };
      
      const validation = validatePayment(paymentData, total_amount);
      if (!validation.valid) {
        return res.status(400).json({ error: validation.error });
      }
      
      const insertOrder = (receiptNumberToInsert) => {
        const finalReceiptNumber = receiptNumberToInsert || receipt_number;
        const final_paid_amount = paymentData.paid_amount;
        
        // Insert order
        // For admins: use branch_id from request body if provided, otherwise use user's branchId
        // For regular users: use their branchId (requireBranchAccess ensures they have one)
        const branchId = req.user.role === 'admin' 
          ? (branch_id || req.user?.branchId || null)
          : (req.user?.branchId || null);
        
        console.log('Creating order with branchId:', branchId, 'for user:', req.user.username, 'role:', req.user.role);
        
        db.run(
          `INSERT INTO orders (receipt_number, customer_id, service_id, quantity, 
            weight_kg, color, special_instructions, delivery_type, express_surcharge_multiplier, total_amount, paid_amount, payment_status, payment_method, created_by, estimated_collection_date, branch_id)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [finalReceiptNumber, customer_id, service_id,
            quantity || 1, weight_kg || null, color || null, special_instructions || null,
            delivery_type || 'standard', expressMultiplier,
            total_amount, final_paid_amount, payment_status || 'not_paid', payment_method || 'cash', created_by || null, estimated_collection_date || null, branchId],
          function(insertErr) {
            if (insertErr) {
              // Log the full error for debugging
              console.error('Order insertion error:', {
                error: insertErr.message,
                code: insertErr.code,
                receiptNumber: finalReceiptNumber,
                retryCount: retryCount
              });
              
              // Handle UNIQUE constraint error (duplicate receipt number) by retrying
              // NOTE: We removed UNIQUE constraint from receipt_number to allow multiple items per receipt
              // But if it still exists (old database), we'll handle it here
              const errorMsg = insertErr.message || '';
              const errorCode = insertErr.code || '';
              const isUniqueError = (errorMsg.includes('UNIQUE constraint failed') || 
                                    errorMsg.includes('SQLITE_CONSTRAINT') ||
                                    errorMsg.includes('UNIQUE constraint') ||
                                    errorCode === 'SQLITE_CONSTRAINT_UNIQUE' ||
                                    errorCode === 'SQLITE_CONSTRAINT') && 
                                   (errorMsg.includes('receipt_number') || errorMsg.includes('receipt') || errorMsg.includes('orders'));
              
              if (isUniqueError) {
                // If we get a UNIQUE error on receipt_number, it means the constraint still exists
                // This shouldn't happen, but if it does, try to remove it
                if (retryCount === 0) {
                  console.warn('âš ï¸ UNIQUE constraint detected on receipt_number. Attempting to remove...');
                  db.run("DROP INDEX IF EXISTS sqlite_autoindex_orders_1", (dropErr) => {
                    if (!dropErr) {
                      console.log('âœ… Removed unique index. Retrying order creation...');
                    }
                    // Retry with same receipt number (if constraint is removed, it should work)
                    // But also try with new receipt number as fallback
                    generateReceiptNumber((err, newReceiptNumber) => {
                      if (err) {
                        console.error('Error generating receipt number after retry:', err);
                        return res.status(500).json({ error: 'Error generating receipt number after retry: ' + err.message });
                      }
                      console.log(`Generated new receipt number for retry: ${newReceiptNumber}`);
                      return createOrder(newReceiptNumber, retryCount + 1);
                    });
                  });
                  return;
                }
                
                if (retryCount < 5) {
                  console.log(`Duplicate receipt number detected: ${finalReceiptNumber}. Retrying (attempt ${retryCount + 1}/5)...`);
                  // Retry with a new receipt number
                  generateReceiptNumber((err, newReceiptNumber) => {
                    if (err) {
                      console.error('Error generating receipt number after retry:', err);
                      return res.status(500).json({ error: 'Error generating receipt number after retry: ' + err.message });
                    }
                    console.log(`Generated new receipt number for retry: ${newReceiptNumber}`);
                    return createOrder(newReceiptNumber, retryCount + 1);
                  });
                  return;
                }
                
                // If we've exhausted retries
                console.error(`Failed after ${retryCount} retries. Receipt number: ${finalReceiptNumber}`);
                return res.status(500).json({ 
                  error: 'Duplicate receipt number detected. Please contact administrator. The UNIQUE constraint on receipt_number should be removed.',
                  details: `Receipt: ${finalReceiptNumber}, Retries: ${retryCount}. Error: ${errorMsg}`
                });
              }
              
              // Return the actual error for non-unique errors
              return res.status(500).json({ 
                error: insertErr.message,
                code: errorCode
              });
            }

            const orderId = this.lastID;

            const orderObj = {
              id: orderId,
              receipt_number: finalReceiptNumber,
              branch_id: branchId
            };

            // Create transaction record if payment was made
            if (final_paid_amount > 0 && (payment_status === 'paid_full' || payment_status === 'advance')) {
              recordPaymentTransaction(orderObj, final_paid_amount, payment_method || 'cash', created_by || 'System')
                .then((transactionId) => {
                  console.log(`âœ… Payment transaction recorded: Transaction ID ${transactionId} for Order ${orderId}`);
                })
                .catch((err) => {
                  console.error('Error recording payment transaction:', err);
                  // Don't fail the order creation if transaction recording fails
                });
            }

            // Log payment creation to audit log
            logPaymentChange({
              order_id: orderId,
              action: 'created',
              new_payment_status: payment_status || 'not_paid',
              new_paid_amount: final_paid_amount,
              new_payment_method: payment_method || 'cash',
              changed_by: created_by || 'System',
              notes: 'Order created'
            }).catch((err) => {
              console.error('Error logging payment change:', err);
            });

            // Get customer details for receipt
            db.get('SELECT * FROM customers WHERE id = ?', [customer_id], (err, customer) => {
              if (err) {
                return res.status(500).json({ error: err.message });
              }

              const order = {
                id: orderId,
                receipt_number: finalReceiptNumber,
                customer_id,
                service_id,
                quantity: quantity || 1,
                weight_kg,
                special_instructions,
                delivery_type: delivery_type || 'standard',
                express_surcharge_multiplier: expressMultiplier,
                total_amount,
                paid_amount: final_paid_amount,
                payment_status: payment_status || 'not_paid',
                payment_method: payment_method || 'cash',
                status: 'pending',
                order_date: new Date().toISOString(),
                estimated_collection_date: estimated_collection_date || null
              };

              const receipt = formatReceipt(order, customer, service);

              // Send order confirmation SMS (optional - can be disabled)
              if (process.env.SEND_ORDER_CONFIRMATION_SMS === 'true' && customer.phone) {
                const smsEnabled = customer.sms_notifications_enabled !== 0;
                if (smsEnabled) {
                  const { generateOrderConfirmation } = require('../utils/sms');
                  const confirmationMessage = generateOrderConfirmation(
                    finalReceiptNumber,
                    customer.name,
                    total_amount,
                    estimated_collection_date
                  );
                  
                  sendSMS(customer.phone, confirmationMessage, {
                    customerId: customer.id,
                    orderId: orderId,
                    notificationType: 'order_confirmation'
                  }).catch(err => {
                    console.error('Error sending order confirmation SMS:', err);
                  });
                }
              }

              res.json({
                order,
                receipt,
                customer,
                service
              });
            });
          }
        );
      };

      // If receipt number was provided in request (for batch orders), use it directly
      if (receipt_number) {
        insertOrder(receipt_number);
      }
      // If receipt number was provided as parameter (for retry), use it
      else if (receiptNumberToUse) {
        insertOrder(receiptNumberToUse);
      } else {
        // Generate receipt number with callback (format: {sequence}-{DD}-{MM} ({YY}))
        generateReceiptNumber((err, generatedReceiptNumber) => {
          if (err) {
            return res.status(500).json({ error: 'Error generating receipt number' });
          }
          insertOrder(generatedReceiptNumber);
        });
      }
    }
  });
  } catch (error) {
    console.error('Error in order creation route:', error);
    return res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// Update order status
router.put('/:id/status', authenticate, requireBranchAccess(), (req, res) => {
  const { id } = req.params;
  const { status } = req.body;

  const validStatuses = ['pending', 'processing', 'ready', 'collected'];
  if (!validStatuses.includes(status)) {
    return res.status(400).json({ error: 'Invalid status' });
  }

  // First verify user has access to this order
  const branchFilter = getBranchFilter(req, 'o');
  db.get(
    `SELECT id FROM orders WHERE id = ? ${branchFilter.clause}`,
    [id, ...branchFilter.params],
    (checkErr, order) => {
      if (checkErr) {
        return res.status(500).json({ error: checkErr.message });
      }
      if (!order) {
        return res.status(404).json({ error: 'Order not found or access denied' });
      }

      // User has access, proceed with update
      let updateQuery = 'UPDATE orders SET status = ?';
      const params = [status];
      const branchId = req.user?.branchId;

      if (status === 'ready') {
        updateQuery += ', ready_date = CURRENT_TIMESTAMP';
        if (branchId) {
          updateQuery += ', ready_at_branch_id = ?';
          params.push(branchId);
        }
      }
      
      if (status === 'collected') {
        updateQuery += ', collected_date = CURRENT_TIMESTAMP';
        if (branchId) {
          updateQuery += ', collected_at_branch_id = ?';
          params.push(branchId);
        }
      }

      updateQuery += ' WHERE id = ?';
      params.push(id);
      
      db.run(updateQuery, params, function(updateErr) {
    if (updateErr) {
      return res.status(500).json({ error: updateErr.message });
    }
    
    if (this.changes === 0) {
      return res.status(404).json({ error: 'Order not found' });
    }
    
    // Send SMS notification when order becomes ready
    if (status === 'ready') {
      db.get(
        `SELECT o.*, c.name as customer_name, c.phone as customer_phone, 
                c.sms_notifications_enabled
         FROM orders o
         JOIN customers c ON o.customer_id = c.id
         WHERE o.id = ?`,
        [id],
        (err, order) => {
          if (!err && order) {
            // Check if customer has SMS notifications enabled (default to true if null)
            const smsEnabled = order.sms_notifications_enabled !== 0;
            
            if (smsEnabled && order.customer_phone) {
              const message = generateReadyNotification(
                order.receipt_number, 
                order.customer_name,
                order.estimated_collection_date
              );
              
              // Send SMS asynchronously (don't block the response)
              sendSMS(order.customer_phone, message, {
                customerId: order.customer_id,
                orderId: order.id,
                notificationType: 'ready'
              }).then(result => {
                if (result.success) {
                  console.log(`âœ… SMS notification sent to ${order.customer_phone} for order ${order.receipt_number}`);
                } else {
                  console.error(`âŒ Failed to send SMS to ${order.customer_phone}:`, result.error);
                }
              }).catch(err => {
                console.error(`âŒ Error sending SMS:`, err);
              });
            } else if (!smsEnabled) {
              console.log(`ðŸ“± SMS notifications disabled for customer ${order.customer_name}`);
            }
          }
        }
      );
    }
    
        res.json({ message: 'Order status updated successfully' });
      });
    }
  );
});

// Update estimated collection date
router.put('/:id/estimated-collection-date', authenticate, requireBranchAccess(), (req, res) => {
  const { id } = req.params;
  const { estimated_collection_date } = req.body;

  if (!estimated_collection_date) {
    return res.status(400).json({ error: 'Estimated collection date is required' });
  }

  // Verify user has access to this order
  const branchFilter = getBranchFilter(req, 'o');
  db.get(
    `SELECT id FROM orders WHERE id = ? ${branchFilter.clause}`,
    [id, ...branchFilter.params],
    (checkErr, order) => {
      if (checkErr) {
        return res.status(500).json({ error: checkErr.message });
      }
      if (!order) {
        return res.status(404).json({ error: 'Order not found or access denied' });
      }

      db.run(
        'UPDATE orders SET estimated_collection_date = ? WHERE id = ?',
        [estimated_collection_date, id],
        function(err) {
      if (err) {
        return res.status(500).json({ error: err.message });
      }
      if (this.changes === 0) {
        return res.status(404).json({ error: 'Order not found' });
      }
      res.json({ message: 'Estimated collection date updated successfully' });
    }
  );
});

// Collect order (by receipt number) with optional payment
router.post('/collect/:receiptNumber', (req, res) => {
  const { receiptNumber } = req.params;
  const { payment_amount, payment_method = 'cash', notes } = req.body;
  
  db.get(
    `SELECT o.*, c.name as customer_name, c.phone as customer_phone
     FROM orders o
     JOIN customers c ON o.customer_id = c.id
     WHERE o.receipt_number = ?`,
    [receiptNumber],
    (err, order) => {
      if (err) {
        return res.status(500).json({ error: err.message });
      }
      if (!order) {
        return res.status(404).json({ error: 'Order not found' });
      }

      if (order.status === 'collected') {
        return res.status(400).json({ error: 'Order already collected' });
      }

      const balanceDue = order.total_amount - (order.paid_amount || 0);
      let finalPaidAmount = order.paid_amount || 0;
      let finalPaymentStatus = order.payment_status;

      // Function to update order after payment processing (defined before use)
      function updateOrder() {
        db.run(
          `UPDATE orders 
           SET status = ?, collected_date = CURRENT_TIMESTAMP, 
               paid_amount = ?, payment_status = ?, payment_method = ?
           WHERE receipt_number = ?`,
          ['collected', finalPaidAmount, finalPaymentStatus, payment_method, receiptNumber],
          function(updateErr) {
            if (updateErr) {
              return res.status(500).json({ error: updateErr.message });
            }
            
            // Award loyalty points on collection (only if fully paid)
            // Note: Loyalty points are awarded asynchronously and may not be in response
            if (finalPaymentStatus === 'paid_full' && order.total_amount > 0) {
              const { awardPointsOnCollection } = require('./loyalty');
              awardPointsOnCollection(order.customer_id, order.id, order.total_amount, (err, result) => {
                if (err) {
                  console.error('Error awarding loyalty points:', err);
                } else {
                  console.log(`âœ… Loyalty points awarded: ${result?.points_earned || 0} points to customer ${order.customer_id}`);
                }
              });
            }
            
            // Get updated order
            db.get(
              `SELECT o.*, s.name as service_name, c.name as customer_name, c.phone as customer_phone
               FROM orders o
               JOIN services s ON o.service_id = s.id
               JOIN customers c ON o.customer_id = c.id
               WHERE o.receipt_number = ?`,
              [receiptNumber],
              (err, updatedOrder) => {
                if (err) {
                  return res.status(500).json({ error: err.message });
                }
                res.json({ 
                  message: 'Order collected successfully', 
                  order: updatedOrder,
                  payment_collected: payment_amount || 0,
                  balance_remaining: updatedOrder.total_amount - updatedOrder.paid_amount
                });
              }
            );
          }
        );
      }

      // Handle payment if provided
      if (payment_amount !== undefined && payment_amount > 0) {
        const paymentAmount = parseFloat(payment_amount);
        
        // Check for duplicate payment
        const timestamp = new Date().toISOString();
        checkDuplicatePayment(order.id, paymentAmount, timestamp)
          .then((isDuplicate) => {
            if (isDuplicate) {
              return res.status(400).json({ error: 'Duplicate payment detected. This payment was already recorded.' });
            }
            
            finalPaidAmount += paymentAmount;
            
            if (finalPaidAmount >= order.total_amount) {
              finalPaymentStatus = 'paid_full';
            } else if (finalPaidAmount > 0) {
              finalPaymentStatus = 'advance';
            }

            // Record payment transaction using utility function
            const orderObj = {
              id: order.id,
              receipt_number: receiptNumber,
              branch_id: order.branch_id || null
            };
            
            recordPaymentTransaction(orderObj, paymentAmount, payment_method, 'Cashier')
              .then((transactionId) => {
                console.log(`âœ… Payment transaction recorded: Transaction ID ${transactionId} for Order ${order.id}`);
                
                // Log payment change to audit log
                logPaymentChange({
                  order_id: order.id,
                  action: 'collected',
                  old_payment_status: order.payment_status,
                  new_payment_status: finalPaymentStatus,
                  old_paid_amount: order.paid_amount || 0,
                  new_paid_amount: finalPaidAmount,
                  old_payment_method: order.payment_method,
                  new_payment_method: payment_method,
                  changed_by: 'Cashier',
                  notes: notes || `Payment at collection for ${receiptNumber}`
                }).catch((err) => {
                  console.error('Error logging payment change:', err);
                });
                
                // Continue with order update
                updateOrder();
              })
              .catch((err) => {
                console.error('Error recording payment transaction:', err);
                return res.status(500).json({ error: 'Error recording payment transaction: ' + err.message });
              });
          })
          .catch((err) => {
            console.error('Error checking duplicate payment:', err);
            return res.status(500).json({ error: 'Error validating payment: ' + err.message });
          });
          
        return; // Exit early, updateOrder will be called after transaction is recorded
      } else {
        // No payment provided, just update order status
        updateOrder();
      }
    }
  );
});

// Receive payment for an order (without collecting)
router.post('/:id/receive-payment', (req, res) => {
  const { id } = req.params;
  const { payment_amount, payment_method = 'cash', notes } = req.body;

  if (!payment_amount || payment_amount <= 0) {
    return res.status(400).json({ error: 'Payment amount must be greater than 0' });
  }

  db.get(
    `SELECT o.*, c.name as customer_name, c.phone as customer_phone
     FROM orders o
     JOIN customers c ON o.customer_id = c.id
     WHERE o.id = ?`,
    [id],
    (err, order) => {
      if (err) {
        return res.status(500).json({ error: err.message });
      }
      if (!order) {
        return res.status(404).json({ error: 'Order not found' });
      }

      const paymentAmount = parseFloat(payment_amount);
      const currentPaidAmount = order.paid_amount || 0;
      const newPaidAmount = currentPaidAmount + paymentAmount;
      const totalAmount = order.total_amount;
      
      // Validate that payment doesn't exceed total
      if (newPaidAmount > totalAmount) {
        return res.status(400).json({ error: `Payment amount (${newPaidAmount.toFixed(2)}) exceeds total amount (${totalAmount.toFixed(2)})` });
      }
      
      // Determine new payment status
      let newPaymentStatus = order.payment_status;
      if (newPaidAmount >= totalAmount) {
        newPaymentStatus = 'paid_full';
      } else if (newPaidAmount > 0) {
        newPaymentStatus = 'advance';
      }

      // Check for duplicate payment
      const timestamp = new Date().toISOString();
      checkDuplicatePayment(order.id, paymentAmount, timestamp)
        .then((isDuplicate) => {
          if (isDuplicate) {
            return res.status(400).json({ error: 'Duplicate payment detected. This payment was already recorded.' });
          }
          
          // Record payment transaction using utility function
          const orderObj = {
            id: order.id,
            receipt_number: order.receipt_number,
            branch_id: order.branch_id || null
          };
          
          recordPaymentTransaction(orderObj, paymentAmount, payment_method, 'Cashier')
            .then((transactionId) => {
              console.log(`âœ… Payment transaction recorded: Transaction ID ${transactionId} for Order ${order.id}`);
              
              // Log payment change to audit log
              logPaymentChange({
                order_id: order.id,
                action: 'payment_received',
                old_payment_status: order.payment_status,
                new_payment_status: newPaymentStatus,
                old_paid_amount: currentPaidAmount,
                new_paid_amount: newPaidAmount,
                old_payment_method: order.payment_method,
                new_payment_method: payment_method,
                changed_by: 'Cashier',
                notes: notes || `Payment received for order ${order.receipt_number}`
              }).catch((err) => {
                console.error('Error logging payment change:', err);
              });

              // Update order payment info
              db.run(
                `UPDATE orders 
                 SET paid_amount = ?, payment_status = ?, payment_method = ?
                 WHERE id = ?`,
                [newPaidAmount, newPaymentStatus, payment_method, id],
                function(updateErr) {
                  if (updateErr) {
                    return res.status(500).json({ error: updateErr.message });
                  }
                  
                  // Get updated order
                  db.get(
                    `SELECT o.*, s.name as service_name, c.name as customer_name, c.phone as customer_phone
                     FROM orders o
                     JOIN services s ON o.service_id = s.id
                     JOIN customers c ON o.customer_id = c.id
                     WHERE o.id = ?`,
                    [id],
                    (err, updatedOrder) => {
                      if (err) {
                        return res.status(500).json({ error: err.message });
                      }
                      res.json({ 
                        message: 'Payment received successfully', 
                        order: updatedOrder,
                        payment_received: paymentAmount,
                        total_paid: newPaidAmount,
                        balance_remaining: updatedOrder.total_amount - newPaidAmount
                      });
                    }
                  );
                }
              );
            })
            .catch((err) => {
              console.error('Error recording payment transaction:', err);
              return res.status(500).json({ error: 'Error recording payment transaction: ' + err.message });
            });
        })
        .catch((err) => {
          console.error('Error checking duplicate payment:', err);
          return res.status(500).json({ error: 'Error validating payment: ' + err.message });
        });
    }
  );
});

// Upload Excel file and import stock/orders
router.post('/upload-stock-excel', authenticate, requireBranchAccess(), upload.single('file'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No file uploaded' });
  }

  const filePath = req.file.path;
  let data = [];

  try {
    // Read Excel file using ExcelJS (more secure than xlsx)
    const workbook = new ExcelJS.Workbook();
    await workbook.xlsx.readFile(filePath);
    const worksheet = workbook.worksheets[0];
    
    // Convert worksheet to JSON array
    worksheet.eachRow((row, rowNumber) => {
      if (rowNumber === 1) return; // Skip header row
      const rowData = {};
      row.eachCell({ includeEmpty: false }, (cell, colNumber) => {
        const header = worksheet.getRow(1).getCell(colNumber).value;
        if (header) {
          rowData[header] = cell.value;
        }
      });
      if (Object.keys(rowData).length > 0) {
        data.push(rowData);
      }
    });

    if (data.length === 0) {
      fs.unlinkSync(filePath);
      return res.status(400).json({ error: 'Excel file is empty' });
    }
  } catch (error) {
    // Clean up uploaded file on error
    try {
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
      }
    } catch (unlinkErr) {
      console.error('Error deleting file:', unlinkErr);
    }
    return res.status(500).json({ error: 'Error processing Excel file: ' + error.message });
  }

  let imported = 0;
  let skipped = 0;
  const errors = [];
  let processed = 0;

  // Define sendResponse function before db.get so it's accessible from nested callbacks
  function sendResponse() {
    // Clean up uploaded file
    try {
      fs.unlinkSync(filePath);
    } catch (unlinkErr) {
      console.error('Error deleting file:', unlinkErr);
    }

    res.json({
      imported,
      skipped,
      total: data.length,
      errors: errors.slice(0, 20) // Limit errors to first 20
    });
  }

  // Get default service (first active service) as fallback
  db.get('SELECT id FROM services WHERE is_active = 1 LIMIT 1', [], (err, defaultService) => {
      if (err) {
        fs.unlinkSync(filePath);
        return res.status(500).json({ error: 'Error getting default service: ' + err.message });
      }
      
      const defaultServiceId = defaultService ? defaultService.id : null;

      // Process each row
      data.forEach((row, index) => {
        // Try to find receipt ID, customer name, and unpaid balance in various column formats
        const receiptId = String(row['Receipt ID'] || row['Receipt ID'] || row['Receipt'] || row['receipt'] || row['Receipt Number'] || row['Receipt Number'] || row['RECEIPT'] || '').trim();
        const customerName = String(row['Customer Name'] || row['Customer name'] || row['customer name'] || row['Name'] || row['name'] || row['NAME'] || row['Customer'] || row['customer'] || '').trim();
        const unpaidBalance = parseFloat(row['Unpaid Balance'] || row['Unpaid balance'] || row['unpaid balance'] || row['Balance'] || row['balance'] || row['BALANCE'] || row['Unpaid'] || row['unpaid'] || 0);
        const totalAmount = parseFloat(row['Total Amount'] || row['Total amount'] || row['total amount'] || row['Total'] || row['total'] || row['TOTAL'] || row['Amount'] || row['amount'] || 0);
        const serviceName = String(row['Service'] || row['service'] || row['Service Name'] || row['service name'] || row['SERVICE'] || '').trim();
        const quantity = parseInt(row['Quantity'] || row['quantity'] || row['Qty'] || row['qty'] || row['QUANTITY'] || 1);
        const phone = String(row['Phone'] || row['phone'] || row['Phone Number'] || row['phone number'] || row['PHONE'] || row['Mobile'] || row['mobile'] || '').trim();

        if (!receiptId || !customerName) {
          errors.push(`Row ${index + 2}: Missing Receipt ID or Customer Name`);
          skipped++;
          processed++;
          if (processed === data.length) {
            sendResponse();
          }
          return;
        }

        // Calculate total and paid amounts
        const finalTotalAmount = totalAmount > 0 ? totalAmount : (unpaidBalance > 0 ? unpaidBalance : 0);
        const paidAmount = finalTotalAmount - unpaidBalance;
        const paymentStatus = unpaidBalance > 0 ? 'advance' : (paidAmount >= finalTotalAmount ? 'paid_full' : 'not_paid');

        // Find or create customer
        db.get('SELECT id FROM customers WHERE name = ? COLLATE NOCASE', [customerName], (err, customer) => {
          if (err) {
            errors.push(`Row ${index + 2}: Error finding customer - ${err.message}`);
            skipped++;
            processed++;
            if (processed === data.length) {
              sendResponse();
            }
            return;
          }

          let customerId = customer ? customer.id : null;

          // If customer not found and phone is provided, create customer
          if (!customerId && phone) {
            db.run(
              'INSERT INTO customers (name, phone) VALUES (?, ?)',
              [customerName, phone],
              function(insertErr) {
                if (insertErr) {
                  errors.push(`Row ${index + 2}: Error creating customer - ${insertErr.message}`);
                  skipped++;
                  processed++;
                  if (processed === data.length) {
                    sendResponse();
                  }
                  return;
                }
                customerId = this.lastID;
                findServiceAndCreateOrder();
              }
            );
          } else if (!customerId) {
            errors.push(`Row ${index + 2}: Customer "${customerName}" not found and no phone provided`);
            skipped++;
            processed++;
            if (processed === data.length) {
              sendResponse();
            }
            return;
          } else {
            findServiceAndCreateOrder();
          }

          function findServiceAndCreateOrder() {
            // Find service by name if provided, otherwise use default
            if (serviceName) {
              db.get('SELECT id FROM services WHERE name = ? COLLATE NOCASE AND is_active = 1', [serviceName], (err, service) => {
                if (err || !service) {
                  // Use default service if service not found
                  createOrder(defaultServiceId);
                } else {
                  createOrder(service.id);
                }
              });
            } else {
              createOrder(defaultServiceId);
            }
          }

          function createOrder(serviceId) {
            if (!serviceId) {
              errors.push(`Row ${index + 2}: No service found and no default service available`);
              skipped++;
              processed++;
              if (processed === data.length) {
                sendResponse();
              }
              return;
            }

            // Check if order with this receipt number already exists
            db.get('SELECT id FROM orders WHERE receipt_number = ?', [receiptId], (err, existingOrder) => {
              if (err) {
                errors.push(`Row ${index + 2}: Error checking existing order - ${err.message}`);
                skipped++;
                processed++;
                if (processed === data.length) {
                  sendResponse();
                }
                return;
              }

              if (existingOrder) {
                errors.push(`Row ${index + 2}: Order with receipt "${receiptId}" already exists`);
                skipped++;
                processed++;
                if (processed === data.length) {
                  sendResponse();
                }
                return;
              }

              // Create order with status 'ready' (stock waiting for collection)
              const branchId = req.user?.branchId || null;
              db.run(
                `INSERT INTO orders (receipt_number, customer_id, service_id, quantity, total_amount, paid_amount, payment_status, payment_method, status, order_date, branch_id, created_at_branch_id)
                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'ready', CURRENT_TIMESTAMP, ?, ?)`,
                [receiptId, customerId, serviceId, quantity, finalTotalAmount, paidAmount, paymentStatus, 'cash', branchId, branchId],
                function(insertErr) {
                  processed++;
                  if (insertErr) {
                    errors.push(`Row ${index + 2}: Error creating order - ${insertErr.message}`);
                    skipped++;
                  } else {
                    imported++;

                    // Create transaction record if payment was made
                    if (paidAmount > 0) {
                      db.run(
                        'INSERT INTO transactions (order_id, transaction_type, amount, payment_method, branch_id) VALUES (?, ?, ?, ?, ?)',
                        [this.lastID, 'payment', paidAmount, 'cash', branchId]
                      );
                    }
                  }

                  if (processed === data.length) {
                    sendResponse();
                  }
                }
              );
            });
          }
        });
      });
    });
    });
});

// Get notification history for an order or customer
router.get('/notifications', (req, res) => {
  const { order_id, customer_id, limit = 50 } = req.query;
  
  let query = `
    SELECT n.*, c.name as customer_name, o.receipt_number
    FROM notifications n
    JOIN customers c ON n.customer_id = c.id
    LEFT JOIN orders o ON n.order_id = o.id
    WHERE 1=1
  `;
  let params = [];
  
  if (order_id) {
    query += ' AND n.order_id = ?';
    params.push(order_id);
  }
  
  if (customer_id) {
    query += ' AND n.customer_id = ?';
    params.push(customer_id);
  }
  
  query += ' ORDER BY n.created_at DESC LIMIT ?';
  params.push(parseInt(limit));
  
  db.all(query, params, (err, rows) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    res.json(rows);
  });
});

// Manually send notification
router.post('/:id/send-notification', authenticate, requireBranchAccess(), (req, res) => {
  const { id } = req.params;
  const { notification_type = 'ready' } = req.body;
  
  db.get(
    `SELECT o.*, c.name as customer_name, c.phone as customer_phone, 
            c.sms_notifications_enabled, c.id as customer_id
     FROM orders o
     JOIN customers c ON o.customer_id = c.id
     WHERE o.id = ?`,
    [id],
    (err, order) => {
      if (err) {
        return res.status(500).json({ error: err.message });
      }
      if (!order) {
        return res.status(404).json({ error: 'Order not found' });
      }
      
      const smsEnabled = order.sms_notifications_enabled !== 0;
      if (!smsEnabled) {
        return res.status(400).json({ error: 'SMS notifications are disabled for this customer' });
      }
      
      if (!order.customer_phone) {
        return res.status(400).json({ error: 'Customer phone number not available' });
      }
      
      let message;
      if (notification_type === 'ready') {
        message = generateReadyNotification(
          order.receipt_number,
          order.customer_name,
          order.estimated_collection_date
        );
      } else if (notification_type === 'reminder') {
        const { generateCollectionReminder } = require('../utils/sms');
        const hoursOverdue = order.estimated_collection_date 
          ? Math.max(0, Math.floor((new Date() - new Date(order.estimated_collection_date)) / (1000 * 60 * 60)))
          : 0;
        message = generateCollectionReminder(order.receipt_number, order.customer_name, hoursOverdue);
      } else {
        return res.status(400).json({ error: 'Invalid notification type' });
      }
      
      sendSMS(order.customer_phone, message, {
        customerId: order.customer_id,
        orderId: order.id,
        notificationType: notification_type
      }).then(result => {
        if (result.success) {
          res.json({ 
            message: 'Notification sent successfully',
            notification_id: result.notificationId
          });
        } else {
          res.status(500).json({ 
            error: 'Failed to send notification',
            details: result.error
          });
        }
      }).catch(err => {
        res.status(500).json({ error: 'Error sending notification: ' + err.message });
      });
    }
  );
});

// Send collection reminder for a specific order
router.post('/:id/send-reminder', authenticate, requireBranchAccess(), (req, res) => {
  const { id } = req.params;
  const { channels = ['sms'] } = req.body;
  const { sendCollectionReminder } = require('../utils/notifications');

  sendCollectionReminder(null, id, Array.isArray(channels) ? channels : [channels])
    .then(result => {
      if (result.success) {
        res.json({
          message: 'Reminder sent successfully',
          result
        });
      } else {
        res.status(400).json({
          error: result.error || 'Failed to send reminder',
          result
        });
      }
    })
    .catch(err => {
      res.status(500).json({ error: 'Error sending reminder: ' + err.message });
    });
});

module.exports = router;
